using Microsoft.Maui.Authentication; using Microsoft.Maui.Controls; using road_rescue.Models; using Supabase; using Supabase.Gotrue; using Provider = Supabase.Gotrue.Constants.Provider; using System; using System.Linq; using System.Threading.Tasks; using Supabase.Postgrest; namespace road_rescue { public partial class logInPage : ContentPage { // Deep link you added to Supabase Auth â†’ Redirect URLs private const string AppCallback = "roadrescue.staging://oauth-callback"; public logInPage() => InitializeComponent(); // EMAIL/PASSWORD LOGIN private async void OnLoginClicked(object sender, EventArgs e) { var email = emailEntry.Text?.Trim(); var password = passwordEntry.Text?.Trim(); if (string.IsNullOrEmpty(email) || string.IsNullOrEmpty(password)) { await DisplayAlert("Error", "Please fill in all fields.", "OK"); return; } try { await SupabaseService.InitializeAsync(); var session = await SupabaseService.Client.Auth.SignInWithPassword(email!, password!); if (session?.User == null) { await DisplayAlert("Login failed", "Invalid email or password.", "OK"); return; } await OnLoginSuccessAsync(session); } catch (Exception ex) { await DisplayAlert("Error", $"Something went wrong: {ex.Message}", "OK"); } } private void signup_Clicked(object sender, EventArgs e) => Navigation.PushAsync(new signUpPage()); // GOOGLE LOGIN via Supabase provider (PKCE) private async void Signinwithgoogle_Clicked(object sender, EventArgs e) { try { await SupabaseService.InitializeAsync(); var state = await SupabaseService.Client.Auth.SignIn( Provider.Google, new SignInOptions { FlowType = Supabase.Gotrue.Constants.OAuthFlowType.PKCE, // ensure code flow RedirectTo = AppCallback, Scopes = "openid email profile" }); var result = await WebAuthenticator.Default.AuthenticateAsync( new WebAuthenticatorOptions { Url = state.Uri, CallbackUrl = new Uri(AppCallback), }); if (result?.Properties is null || !result.Properties.TryGetValue("code", out var code) || string.IsNullOrWhiteSpace(code)) { await DisplayAlert("Sign-in canceled", "No auth code returned.", "OK"); return; } var session = await SupabaseService.Client.Auth.ExchangeCodeForSession(state.PKCEVerifier, code); if (session?.User == null) { await DisplayAlert("Error", "Failed to create Supabase session.", "OK"); return; } await OnLoginSuccessAsync(session); } catch (TaskCanceledException) { /* user backed out */ } catch (Exception ex) { await DisplayAlert("Error", $"Google sign-in failed: {ex.Message}", "OK"); } } // Shared post-login path private async Task OnLoginSuccessAsync(Supabase.Gotrue.Session session) { // 1) Persist tokens so we can restore the session on next launch try { if (!string.IsNullOrWhiteSpace(session.AccessToken) && !string.IsNullOrWhiteSpace(session.RefreshToken)) { await SecureStorage.Default.SetAsync("sb_access", session.AccessToken); await SecureStorage.Default.SetAsync("sb_refresh", session.RefreshToken); } } catch { /* SecureStorage can throw on some platforms if value is null/empty */ } // 2) Ensure profile exists and get role var uidStr = session.User.Id; var appUserResp = await SupabaseService.Client .From<AppUser>() .Select("*") .Filter("user_id", Supabase.Postgrest.Constants.Operator.Equals, uidStr) .Get(); var appUser = appUserResp.Models.FirstOrDefault(); if (appUser == null) { var uid = Guid.TryParse(uidStr, out var g) ? g : Guid.Empty; appUser = new AppUser { UserId = uid, FullName = session.User.Email ?? "User", Email = session.User.Email ?? string.Empty, Role = "Driver" }; // Use UPSERT to be idempotent await SupabaseService.Client .From<AppUser>() .Upsert(appUser, new QueryOptions { OnConflict = "user_id", Returning = QueryOptions.ReturnType.Representation }); } // 3) Swap to your XAML Shell and route by role Application.Current.MainPage = new AppShell(); if (string.Equals(appUser.Role, "Mechanic", StringComparison.OrdinalIgnoreCase)) await Shell.Current.GoToAsync("//requests"); else await Shell.Current.GoToAsync("//landing"); // 4) Keep tokens fresh whenever Supabase refreshes/updates the session SupabaseService.Client.Auth.AddStateChangedListener((_, state) => { var s = SupabaseService.Client.Auth.CurrentSession; if (state == Supabase.Gotrue.Constants.AuthState.TokenRefreshed || state == Supabase.Gotrue.Constants.AuthState.SignedIn || state == Supabase.Gotrue.Constants.AuthState.UserUpdated) { if (s != null) { _ = (Supabase.Gotrue.Interfaces.IGotrueClient<User, Session>)SecureStorage.Default.SetAsync("sb_access", s.AccessToken ?? ""); _ = (Supabase.Gotrue.Interfaces.IGotrueClient<User, Session>)SecureStorage.Default.SetAsync("sb_refresh", s.RefreshToken ?? ""); } } else if (state == Supabase.Gotrue.Constants.AuthState.SignedOut) { SecureStorage.Default.Remove("sb_access"); SecureStorage.Default.Remove("sb_refresh"); } }); } private async Task<bool> IsMechanicVerifiedAsync(Guid userId) { var mResp = await SupabaseService.Client .From<MechanicDetails>() .Select("is_verified") .Filter("user_id", Supabase.Postgrest.Constants.Operator.Equals, userId.ToString()) .Get(); var mech = mResp.Models.FirstOrDefault(); return mech != null && mech.IsVerified; } } }